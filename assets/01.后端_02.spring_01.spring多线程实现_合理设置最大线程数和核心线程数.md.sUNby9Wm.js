import{_ as o,I as r,c as a,o as p,k as s,a as l,s as e,aM as d,x as n}from"./chunks/framework.rpVorFPB.js";const E=JSON.parse('{"title":"spring多线程实现+合理设置最大线程数和核心线程数","description":"","frontmatter":{"title":"spring多线程实现+合理设置最大线程数和核心线程数","date":"2024-10-09T23:10:53.000Z","permalink":"/service/5b4277/","categories":["后端"],"tags":["spring","java","spring boot","线程池"],"coverImg":"https://cdn.luoyuanxiang.top/img/bg/9.webp"},"headers":[],"relativePath":"01.后端/02.spring/01.spring多线程实现+合理设置最大线程数和核心线程数.md","filePath":"01.后端/02.spring/01.spring多线程实现+合理设置最大线程数和核心线程数.md","lastUpdated":1757121101000}'),u={name:"01.后端/02.spring/01.spring多线程实现+合理设置最大线程数和核心线程数.md"},g={id:"articleContentId"},m={start:"2"},k={id:"AshX5"};function _(b,i,f,y,P,C){const t=r("font");return p(),a("div",null,[i[11]||(i[11]=s("h1",{id:"spring多线程实现-合理设置最大线程数和核心线程数",tabindex:"-1"},[l("spring多线程实现+合理设置最大线程数和核心线程数 "),s("a",{class:"header-anchor",href:"#spring多线程实现-合理设置最大线程数和核心线程数","aria-label":'Permalink to "spring多线程实现+合理设置最大线程数和核心线程数"'},"​")],-1)),i[12]||(i[12]=s("h2",{id:"f2uP7"},"线程运行规则",-1)),i[13]||(i[13]=s("p",null,[s("img",{src:"https://cdn.luoyuanxiang.top/img/cd69692de94f79a594b2bf1619a0ed09.jpeg",alt:"画板",loading:"lazy"})],-1)),s("h2",g,[e(t,{style:{color:"rgb(79, 79, 79)"}},{default:n(()=>i[0]||(i[0]=[l("手动设置线程池，就要合理设置最大线程数和核心线程数，按照网上大多数的说法，都是跟服务器的CPU有关")])),_:1,__:[0]})]),i[14]||(i[14]=l(" 1. ")),e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[1]||(i[1]=[l("先看下机器的CPU核数，然后在设定具体参数：")])),_:1,__:[1]}),i[15]||(i[15]=d('<div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Runtime.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRuntime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">availableProcessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>',1)),e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[2]||(i[2]=[l("即 CPU核数 = Runtime.getRuntime().availableProcessors()")])),_:1,__:[2]}),s("ol",m,[s("li",null,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[3]||(i[3]=[l("分析下线程池处理的程序是CPU密集型，还是IO密集型")])),_:1,__:[3]}),s("ol",null,[s("li",null,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[4]||(i[4]=[l("IO密集型：大量网络，文件操作")])),_:1,__:[4]})]),s("li",null,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[5]||(i[5]=[l("IO密集型：核心线程数 = CPU核数 * 2")])),_:1,__:[5]})]),s("li",null,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[6]||(i[6]=[l("CPU 密集型：大量计算，cpu 占用越接近 100%, 耗费多个核或多台机器")])),_:1,__:[6]})]),s("li",null,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[7]||(i[7]=[l("CPU密集型：核心线程数 = CPU核数 + 1")])),_:1,__:[7]})]),s("li",null,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[8]||(i[8]=[l("注：IO密集型（某大厂实践经验）")])),_:1,__:[8]})]),s("li",null,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[9]||(i[9]=[l("核心线程数 = CPU核数 / （1-阻塞系数） 例如阻塞系数 0.8，CPU核数为4，则核心线程数为20")])),_:1,__:[9]})])])])]),i[16]||(i[16]=s("p",null,[s("img",{src:"https://cdn.luoyuanxiang.top/img/1725862154539-4564f526-7980-46d0-9a33-4fa83f9e23d6.jpeg",alt:"画板",loading:"lazy"})],-1)),s("h2",k,[e(t,{style:{color:"rgb(77, 77, 77)"}},{default:n(()=>i[10]||(i[10]=[l("maxPoolSize")])),_:1,__:[10]})]),i[17]||(i[17]=l(" 当系统负载达到最大值时，核心线程数已无法按时处理完所有任务，这时就需要增加线程。每秒200个任务需要20个线程，那么当每秒达到1000个任务时，则需要(1000-queueCapacity)*(20/200)，即60个线程，可将maxPoolSize设置为60。还有说法就是 cpuNUM*2 或者是cpuNUM*4 ")),i[18]||(i[18]=s("h2",{id:"TJ2to"},"keepAliveTime",-1)),i[19]||(i[19]=l(" 线程数量只增加不减少也不行。当负载降低时，可减少线程数量，如果一个线程空闲时间达到keepAliveTiime，该线程就退出。默认情况下线程池最少会保持corePoolSize个线程。 ")),i[20]||(i[20]=s("h2",{id:"DFp3U"},"allowCoreThreadTimeout",-1)),i[21]||(i[21]=l(" 默认情况下核心线程不会退出，可通过将该参数设置为true，让核心线程也退出。 ")),i[22]||(i[22]=s("h2",{id:"UawPT"},"queueCapacity",-1)),i[23]||(i[23]=l(" 任务队列的长度要根据核心线程数，以及系统对任务响应时间的要求有关。队列长度可以设置为(corePoolSize/tasktime)*responsetime： (20/0.1)*2=400，即队列长度可设置为400。 ")),i[24]||(i[24]=s("p",null,"队列长度设置过大，会导致任务响应时间过长，切忌以下写法：",-1)),i[25]||(i[25]=s("p",null,"LinkedBlockingQueue queue = new LinkedBlockingQueue();",-1)),i[26]||(i[26]=s("p",null,"这实际上是将队列长度设置为Integer.MAX_VALUE，将会导致线程数量永远为corePoolSize，再也不会增加，当任务数量陡增时，任务响应时间也将随之陡增。",-1))])}const U=o(u,[["render",_]]);export{E as __pageData,U as default};
